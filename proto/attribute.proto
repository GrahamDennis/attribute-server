syntax = "proto3";

package me.grahamdennis.attribute;

service AttributeStore {
  rpc Ping(PingRequest) returns (PingResponse);

  rpc CreateAttributeType(CreateAttributeTypeRequest) returns (CreateAttributeTypeResponse);
  rpc GetEntity(GetEntityRequest) returns (GetEntityResponse);
  rpc QueryEntities(QueryEntitiesRequest) returns (QueryEntitiesResponse);
  rpc UpdateEntity(UpdateEntityRequest) returns (UpdateEntityResponse);
  rpc WatchEntities(WatchEntitiesRequest) returns (stream WatchEntitiesEvent);
}

message PingRequest {}
message PingResponse {}

enum ValueType {
  INVALID = 0;
  TEXT = 1;
  ENTITY_REFERENCE = 2;
  BYTES = 3;
}

message CreateAttributeTypeRequest {
  AttributeType attribute_type = 1;
}

message AttributeType {
  string symbol = 1;
  ValueType value_type = 2;
  // FIXME: more information will be required, e.g.:
  //   * uniqueness
  //   * ownership / read/write permissions
}

message CreateAttributeTypeResponse {
  Entity entity = 1;
}

message GetEntityRequest {
  EntityLocator entity_locator = 1;
}

message GetEntityResponse {
  Entity entity = 1;
}

message QueryEntitiesRequest {
  EntityQueryNode root = 1;
  repeated string attribute_types = 2;
}

message QueryEntitiesResponse {
  repeated EntityRow rows = 1;
}

message EntityLocator {
  oneof locator {
    string entity_id = 1;
    string symbol = 2;
  }
}

message Entity {
  string entity_id = 1;
  map<string, AttributeValue> attributes = 2;
}

message EntityRow {
  repeated NullableAttributeValue values = 1;
}

message AttributeValue {
  oneof attribute_value {
    string string_value = 1;
    string entity_id_value = 2;
    bytes bytes_value = 3;
  }
}

message NullableAttributeValue {
  optional AttributeValue value = 1;
}

message EntityQueryNode {
  oneof query {
    MatchAllQueryNode match_all = 1;
    MatchNoneQueryNode match_none = 2;
    AndQueryNode and_ = 3;
    OrQueryNode or_ = 4;
//    MatchEntityIdQueryNode match_entity_id = 5;
//    MatchSymbolQueryNode match_symbol = 6;
//    MatchAttributeValueQueryNode match_attribute_value = 7;
  }
}

message MatchAllQueryNode {}
message MatchNoneQueryNode {}
message AndQueryNode {
  repeated EntityQueryNode clauses = 1;
}

message OrQueryNode {
  repeated EntityQueryNode clauses = 1;
}

message UpdateEntityRequest {
  EntityLocator entity_locator = 1;
  repeated AttributeToUpdate attributes_to_update = 2;
  // FIXME: Could this be made conditional like a compare-and-swap?
}

message AttributeToUpdate {
  string attribute_type = 1;
  optional AttributeValue attribute_value = 2;
}

message UpdateEntityResponse {
  Entity entity = 1;
}

message WatchEntitiesRequest {
  EntityQueryNode query = 1;
}

message WatchEntitiesEvent {
  Entity before = 1;
  Entity after = 2;
}